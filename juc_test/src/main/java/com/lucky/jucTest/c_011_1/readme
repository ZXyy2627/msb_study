synchronized底层实现原理     这是一个面试题
包含一个锁自动升级的概念
其实有4种状态
1.无锁状态  没有线程来争抢
2.偏向锁 被markword  记住线程id，  下次再来一个线程，看ID是不是同一个
3.自旋锁 又叫轻量级锁  又来一个线程争抢锁，这时候升级成自旋锁，顾名思义就是自己旋转等待获取锁，当到达一定次数的时候，就升级成重量级锁
4.重量级锁

其实是在jdk1.6之后才优化了synchronized锁，在1.6之前，synchronized就是重量级锁，为什么要优化重量级锁
原因就是：在多线程争抢锁的时候，如果是重量级锁，每次去获取锁都会消耗操作系统的资源，这样资源消耗过大，所以就优化成，在线程数量少的时候
就用轻量级锁，这样消耗系统的资源少

这里没有说得太清楚，在学习了JVM后详细解释

sync (Object)
markword 记录这个线程ID （偏向锁）
如果线程争用：升级为 自旋锁
10次以后，
升级为重量级锁 - OS

总结：
执行时间短（加锁代码），线程数少，用自旋
执行时间长，线程数多，用系统锁